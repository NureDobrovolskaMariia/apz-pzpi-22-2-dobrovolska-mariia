Міністерство освіти і науки України Харківський національний університет радіоелектроніки

Кафедра програмної інженерії

Звіт
З лабораторної роботи №5
З дисципліни «Архітектура програмного забезпечення» на тему: «РОЗГОРТАННЯ СИСТЕМИ»

Виконала:
ст. гр. ПЗПІ-22-7							Добровольська М.А.

Перевірив:
ст. викладач каф. ПІ						Сокорчук І. П.













Харків 2025
 
1	ІСТОРІЯ ЗМІН


№	Дата	      Версія звіту	Опис	змін	та виправлень
1	29.05.2025	0.1	          Створено структуру звіту. Визначено завдання	на лабораторну роботу
2	31.05.2025	0.1	          Описано хід роботи, додаток А, додаток Б, додаток В. Сформульовано висновок роботи

2	ЗАВДАННЯ

Метою даного лабораторного заняття є розгортання програмної системи.

3	ОПИС ВИКОНАНОЇ РОБОТИ

У рамках виконання лабораторної роботи було реалізовано повноцінне розгортання інформаційно-аналітичної IoT-системи для автоматизованого моніторингу параметрів інкубації. Усі графічні матеріали винесено до додатку Б, а відеодемонстрація – до додатку А.
Процес складався з декількох ключових етапів:
1. Обрання платформи для розгортання
Для хостингу було обрано DigitalOcean, що забезпечує високу стабільність, можливість керування сервером на рівні ОС, гнучке налаштування мережевих політик, підтримку постійних з’єднань (наприклад, для MQTT) та зручну інтеграцію з GitHub.
Порівняльний аналіз платформ:
Платформа	Переваги	Недоліки
Vercel	Просте CI/CD, безсерверна архітектура	Не підтримує довгі MQTT-з'єднання
Railway	Зручний CLI, Git інтеграція	Проблеми з timeout при великому трафіку
Heroku	Класична підтримка Node.js	Платний тариф після пробного періоду
DigitalOcean	Повний root-доступ, постійні з'єднання, контроль	Потрібно ручне налаштування інфраструктури


2. Розгортання бекенд-сервера
Бекенд створено на основі Node.js + Express, з підключенням до MongoDB Atlas та підтримкою RESTful API для взаємодії з мобільним додатком.
Послідовність дій:
1. Створення Droplet (Ubuntu 22.04 LTS)
2. SSH підключення

3. Встановлення Node.js
curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
apt install -y nodejs

4. Клонування репозиторію
git clone https://github.com/NureDobrovolskaMariia/apz-pzpi-22-2-dobrovolska-mariia

5. Встановлення залежностей
npm install

6. Налаштування змінних середовища
nano .env
PORT=3001
MONGODB_URI=mongodb+srv://...
JWT_SECRET=...
MQTT_BROKER=broker.hivemq.com:1883

7. Запуск бекенду
node server.js


Для забезпечення доступності було налаштовано UFW (Firewall) та проксінг через Nginx, а також використано PM2 для автозапуску після перезавантаження сервера.



ВИСНОВКИ

У результаті виконання лабораторної роботи було повністю реалізовано розгортання всіх ключових елементів системи автоматизації процесу інкубації яєць, зокрема: серверної частини на базі Node.js з REST API, клієнтського Android-застосунку, клієнтського web-застосунку, а також IoT-компонентів, що забезпечують збір та передачу даних у реальному часі.
Серверна частина була успішно задеплоєна на віртуальному хмарному сервері DigitalOcean, що дало змогу досягти високої доступності та стабільності. Було налаштовано безпечну взаємодію з базою даних MongoDB Atlas, інтеграцію з MQTT-брокером для обробки алертів, а також авторизацію користувачів через JWT.
Мобільний застосунок, реалізований на Kotlin, ефективно взаємодіє з API сервера, надаючи зручний інтерфейс для перегляду пристроїв, налаштувань алертів, перегляду критичних подій та персонального профілю користувача.
Розроблено клієнтську частину вебдодатку для системи автоматизації інкубаційного процесу. Інтерфейс реалізовано з використанням HTML, CSS та JavaScript, без застосування сторонніх фреймворків, що дозволило досягти простоти, високої продуктивності та кросплатформеності. Створено ключові сторінки застосунку: авторизації, реєстрації, перегляду пристроїв, сторінки з поточними та критичними тривогами, профілю користувача, а також окремої адмін-панелі. 

Завдяки належному налаштуванню мережі, хостингу, змінних середовища, логування та управління процесами, було досягнуто повної інтеграції всіх компонентів системи в єдину цифрову екосистему. Отримані результати підтверджують коректну роботу всіх елементів, відповідність поставленим функціональним вимогам та ефективність обраної архітектури розгортання.
Public URL: https://octopus-app-tv6oa.ondigitalocean.app/


 
ДОДАТОК А
Відеозапис

Відеозапис	презентації	результатів	лабораторної	роботи:
https://youtu.be/p13-gYMGRdE

Хронологічний опис відеозапису:

00:15 - Опис схеми
00:50 - Демонмтрація роботи
02:30 - Опис коду для ESP32
05:57 - Опис коду на сервері 
ДОДАТОК Б
Графічні матеріали



 
Рисунок Б.1 — Загальна архітектура


 

Рисунок Б.3 — Структура бази даних
 

 
Рисунок Б.1 – UML Діаграма прецедентів





ДОДАТОК В
Програмний код

GitHub репозиторій: 

https://github.com/NureDobrovolskaMariia/apz-pzpi-22-2-dobrovolska-mariia/blob/main/Lab5/pzpi-22-2-dobrovolska-mariia-lab5/server.js

Код мого entry point у систему

1	// server.js
2	require('dotenv').config();
3	const express = require('express');
4	const mongoose = require('mongoose');
5	const cors = require('cors');
6	const helmet = require('helmet');
7	const rateLimit = require('express-rate-limit');
8	const path = require('path'); // Добавляем модуль path

9	// Services
10	const mqttService = require('./services/mqttService');

11	// Middleware
12	const { globalErrorHandler, notFound } = require('./middleware/errorHandler');
13	const { requestLogger, apiAnalytics, securityLogger, rateLimitLogger } = require('./middleware/logger');

14	// Routes
15	const authRoutes = require('./routes/auth');
16	const deviceRoutes = require('./routes/devices');
17	const dataRoutes = require('./routes/data');
18	const alertRoutes = require('./routes/alerts');
19	const userRoutes = require('./routes/users');

20	const app = express();
21	const PORT = process.env.PORT || 3001;

22	// Security middleware
23	app.use(
24	helmet.contentSecurityPolicy({
25	directives: {
26	...helmet.contentSecurityPolicy.getDefaultDirectives(), // Беремо стандартні директиви
27	"script-src": ["'self'", "https://cdn.jsdelivr.net"], // Дозволяємо 'self' та cdn.jsdelivr.net
28	// Якщо Chart.js використовує inline стилі або eval, можливо, знадобиться 'unsafe-inline' або 'unsafe-eval',
29	// але краще цього уникати. Для Chart.js v3 зазвичай достатньо джерела скрипту.
30	// "style-src": ["'self'", "https://cdn.jsdelivr.net", "'unsafe-inline'"], // Приклад, якщо потрібні стилі з CDN
31	},
32	})
33	);
34	app.use(cors());

35	// Logging middleware
36	if (process.env.NODE_ENV === 'development') {
37	app.use(requestLogger);
38	app.use(apiAnalytics);
39	}
40	app.use(securityLogger);
41	app.use(rateLimitLogger);

42	// Rate limiting
43	const limiter = rateLimit({
44	windowMs: 15 * 60 * 100000, // 15 minutes
45	max: 100 // limit each IP to 100 requests per windowMs
46	});
47	app.use(limiter);

48	// Body parser middleware
49	app.use(express.json({ limit: '10mb' }));
50	app.use(express.urlencoded({ extended: true }));

51	// Serve static files from the 'web' directory
52	app.use(express.static(path.join(__dirname, 'web'))); //

53	// MongoDB connection
54	mongoose.connect(process.env.MONGODB_URI, {
55	useNewUrlParser: true,
56	useUnifiedTopology: true,
57	})
58	.then(() => {
59	console.log('✅ Connected to MongoDB');
60	})
61	.catch((error) => {
62	console.error('❌ MongoDB connection error:', error);
63	process.exit(1);
64	});

65	// Database connection events
66	mongoose.connection.on('disconnected', () => {
67	console.log('📴 MongoDB disconnected');
68	});

69	mongoose.connection.on('error', (error) => {
70	console.error('❌ MongoDB error:', error);
71	});

72	// Routes
73	app.get('/', (req, res) => {
74	// Instead of JSON, now serve the login page by default
75	res.sendFile(path.join(__dirname, 'web', 'html', 'login.html')); //
76	});

77	// Health check endpoint
78	app.get('/health', (req, res) => {
79	const health = {
80	status: 'OK',
81	timestamp: new Date().toISOString(),
82	uptime: process.uptime(),
83	database: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
84	mqtt: mqttService.isConnected ? 'connected' : 'disconnected',
85	memory: process.memoryUsage(),
86	environment: process.env.NODE_ENV || 'development'
87	};

88	res.json(health);
89	});

90	// API Routes
91	app.use('/api/auth', authRoutes); //
92	app.use('/api/devices', deviceRoutes); //
93	app.use('/api/data', dataRoutes); //
94	app.use('/api/alerts', alertRoutes); //
95	app.use('/api/users', userRoutes); //

96	// MQTT test endpoint
97	app.post('/api/test/command', (req, res) => { //
98	try {
99	const { userId, deviceId, command } = req.body;

100	if (!userId || !deviceId || !command) {
101	return res.status(400).json({ error: 'Missing required fields' });
102	}

103	mqttService.sendCommand(userId, deviceId, command);
104	res.json({ message: 'Command sent successfully' });
105	} catch (error) {
106	res.status(500).json({ error: error.message });
107	}
108	});

109	// 404 handler for undefined routes
110	app.use(notFound); //

111	// Global error handling middleware
112	app.use(globalErrorHandler); //

113	// Graceful shutdown
114	process.on('SIGTERM', gracefulShutdown); //
115	process.on('SIGINT', gracefulShutdown); //

116	function gracefulShutdown(signal) { //
117	console.log(`\n📴 Received ${signal}. Graceful shutdown...`);

118	// Close MQTT connection
119	mqttService.disconnect();

120	// Close MongoDB connection
121	mongoose.connection.close(() => {
122	console.log('📴 MongoDB connection closed');
123	process.exit(0);
124	});
125	}

126	// Start server
127	app.listen(PORT, () => {
128	console.log(`🚀 Server running on port ${PORT}`);
129	console.log(`📱 Environment: ${process.env.NODE_ENV || 'development'}`);

130	// Initialize MQTT connection
131	mqttService.connect();
132	});

133	module.exports = app; 



